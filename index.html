<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cute Cat â€” Super Interactive</title>
<style>
  html,body { 
    height:100%; margin:0; 
    display:flex; align-items:center; justify-content:center; 
    background:#f7f8fb; 
  }
  canvas { 
    background:transparent; 
    touch-action: none; 
  }
  .ui-hint { 
    position:fixed; left:12px; bottom:12px; 
    font-family:system-ui,-apple-system,Segoe UI,Roboto; 
    color:#555; font-size:14px;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="ui-hint">ðŸ‘† Move mouse/finger â†’ cat looks â€¢ Tap/click â†’ pet the cat ðŸ’–</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  // responsive canvas
  function resize() {
    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    const size = Math.min(window.innerWidth, window.innerHeight) * 0.75;
    canvas.width = Math.round(size * DPR);
    canvas.height = Math.round(size * DPR);
    canvas.style.width = Math.round(size) + 'px';
    canvas.style.height = Math.round(size) + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // state
  const state = {
    t: 0,
    lastBlink: 0,
    blinkDuration: 140, 
    blinkInterval: 3000 + Math.random()*2000,
    isBlinking: false,
    cursor: { x: canvas.width/2, y: canvas.height/2 },
    scalePulse: 0,
    earTwitch: 0,
    hearts: [] // store heart particles
  };

  function now(){ return performance.now(); }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

  // pointer events
  function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches && e.touches[0]) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    return { x: (clientX - rect.left), y: (clientY - rect.top) };
  }

  function onPointerMove(e){
    const p = getPointerPos(e);
    state.cursor.x = p.x;
    state.cursor.y = p.y;
  }
  function onPointerDown(e){
    state.scalePulse = 1.0; // start pet pulse

    // spawn heart
    const rect = canvas.getBoundingClientRect();
    state.hearts.push({
      x: rect.width/2,
      y: rect.height/2 - 60, // just above cat head
      size: 18 + Math.random()*6,
      vy: -0.5 - Math.random()*0.3,
      life: 1.0 // fades out from 1 â†’ 0
    });
  }

  canvas.addEventListener('mousemove', onPointerMove);
  canvas.addEventListener('touchmove', onPointerMove, {passive:false});
  canvas.addEventListener('mousedown', onPointerDown);
  canvas.addEventListener('touchstart', onPointerDown);

  // helper drawing
  function roundEllipse(ctx, x, y, w, h) {
    ctx.beginPath();
    ctx.ellipse(x, y, w, h, 0, 0, Math.PI*2);
  }
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    const rx = Math.min(r, w/2), ry = Math.min(r, h/2);
    ctx.moveTo(x+rx, y);
    ctx.arcTo(x+w, y, x+w, y+h, rx);
    ctx.arcTo(x+w, y+h, x, y+h, ry);
    ctx.arcTo(x, y+h, x, y, rx);
    ctx.arcTo(x, y, x+w, y, ry);
    ctx.closePath();
  }

  function drawEye(ctx, openness = 1, pupilOffsetX=0, pupilOffsetY=0) {
    const eyeW = 16;
    const eyeH = 10 * openness;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(0, 0, eyeW, Math.max(1, eyeH), 0, 0, Math.PI*2);
    ctx.fill();
    // pupil
    ctx.fillStyle = '#2b2b2b';
    ctx.beginPath();
    ctx.ellipse(pupilOffsetX, pupilOffsetY, 5, 5, 0, 0, Math.PI*2);
    ctx.fill();
    // highlight
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.ellipse(pupilOffsetX-2, pupilOffsetY-2, 1.6, 1.6, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // draw heart particle
  function drawHeart(x, y, size, alpha) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(size/20, size/20);
    ctx.fillStyle = `rgba(255, 80, 120, ${alpha})`;
    ctx.beginPath();
    ctx.moveTo(0, -5);
    ctx.bezierCurveTo(-8, -15, -20, -5, 0, 15);
    ctx.bezierCurveTo(20, -5, 8, -15, 0, -5);
    ctx.fill();
    ctx.restore();
  }

  // draw cat
  function drawCat(cx, cy, scale) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);

    // tail (behind body)
    ctx.save();
    const wag = Math.sin(state.t*2.5) * 0.9;
    ctx.translate(-60, 12);
    ctx.rotate(wag * 0.2);
    ctx.fillStyle = '#f4d9c8';
    roundRect(ctx, -6, -6, 80, 18, 10);
    ctx.fill();
    ctx.restore();

    // body
    ctx.fillStyle = '#f4d9c8';
    roundEllipse(ctx, 0, 22, 70, 58); ctx.fill();
    ctx.fillStyle = '#fff4ea';
    roundEllipse(ctx, 0, 32, 45, 28); ctx.fill();

    // head
    ctx.save();
    ctx.translate(0, -38);
    ctx.fillStyle = '#f4d9c8';
    roundEllipse(ctx, 0, 0, 60, 54); ctx.fill();

    // ear twitch
    const twitch = Math.sin(state.earTwitch*20) * Math.exp(-state.earTwitch*3);
    // left ear
    ctx.save();
    ctx.translate(-26, -34);
    ctx.rotate(-0.3 + twitch*0.2);
    ctx.beginPath();
    ctx.moveTo(-8, 0); ctx.lineTo(-22, -30); ctx.lineTo(0, -2);
    ctx.closePath(); ctx.fillStyle = '#f4d9c8'; ctx.fill();
    ctx.fillStyle = '#ffd6c9';
    ctx.beginPath(); ctx.moveTo(-6, -2); ctx.lineTo(-16, -20); ctx.lineTo(-2, -4);
    ctx.closePath(); ctx.fill();
    ctx.restore();

    // right ear
    ctx.save();
    ctx.translate(26, -34);
    ctx.rotate(0.3 - twitch*0.2);
    ctx.beginPath();
    ctx.moveTo(8, 0); ctx.lineTo(22, -30); ctx.lineTo(0, -2);
    ctx.closePath(); ctx.fillStyle = '#f4d9c8'; ctx.fill();
    ctx.fillStyle = '#ffd6c9';
    ctx.beginPath(); ctx.moveTo(6, -2); ctx.lineTo(16, -20); ctx.lineTo(2, -4);
    ctx.closePath(); ctx.fill();
    ctx.restore();

    // eyes
    const eyeY = -4, eyeSpacing = 22, pupilOffsetMax = 6;
    const rect = canvas.getBoundingClientRect();
    const dx = ((state.cursor.x - rect.width/2) / (rect.width/2));
    const dy = ((state.cursor.y - rect.height/2) / (rect.height/2));
    const pupilDX = clamp(dx, -1, 1) * pupilOffsetMax;
    const pupilDY = clamp(dy, -0.7, 0.7) * pupilOffsetMax;

    const openness = state.isBlinking ? 0 : 1;

    ctx.save();
    ctx.translate(-eyeSpacing, eyeY);
    drawEye(ctx, openness, pupilDX, pupilDY);
    ctx.restore();

    ctx.save();
    ctx.translate(eyeSpacing, eyeY);
    drawEye(ctx, openness, pupilDX, pupilDY);
    ctx.restore();

    // nose
    ctx.fillStyle = '#f08b86';
    ctx.beginPath();
    ctx.ellipse(0, 6, 6, 4, 0, 0, Math.PI*2);
    ctx.fill();

    // mouth
    ctx.strokeStyle = '#b35b58'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, 8); ctx.quadraticCurveTo(-8, 12, -16, 14);
    ctx.moveTo(0, 8); ctx.quadraticCurveTo(8, 12, 16, 14);
    ctx.stroke();

    // whiskers
    ctx.strokeStyle = '#bbaaa3'; ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(-16, 6); ctx.lineTo(-46, 2);
    ctx.moveTo(-16, 10); ctx.lineTo(-46, 14);
    ctx.moveTo(16, 6); ctx.lineTo(46, 2);
    ctx.moveTo(16, 10); ctx.lineTo(46, 14);
    ctx.stroke();

    // blush
    ctx.fillStyle = 'rgba(255,120,150,0.18)';
    roundEllipse(ctx, -22, 12, 12, 8); ctx.fill();
    roundEllipse(ctx, 22, 12, 12, 8); ctx.fill();

    ctx.restore(); // head
    ctx.restore(); // whole
  }

  // loop
  let lastTime = performance.now();
  function frame(ts) {
    const dt = ts - lastTime;
    lastTime = ts;
    state.t += dt/1000;

    // blink
    if (!state.isBlinking && (now() - state.lastBlink > state.blinkInterval)) {
      state.isBlinking = true;
      state.lastBlink = now();
    } else if (state.isBlinking && (now() - state.lastBlink > state.blinkDuration)) {
      state.isBlinking = false;
      state.lastBlink = now();
      state.blinkInterval = 2500 + Math.random()*3000;
    }

    // ear twitch trigger randomly
    if (Math.random() < 0.002 && state.earTwitch <= 0) {
      state.earTwitch = 1;
    }
    if (state.earTwitch > 0) state.earTwitch -= dt/1000;

    // pet pulse decay
    if (state.scalePulse > 0) state.scalePulse = Math.max(0, state.scalePulse - dt/300);

    // update hearts
    state.hearts.forEach(h => {
      h.y += h.vy * (dt/16);
      h.life -= dt/2000;
    });
    state.hearts = state.hearts.filter(h => h.life > 0);

    ctx.clearRect(0,0,canvas.width,canvas.height);

    const w = canvas.clientWidth, h = canvas.clientHeight;
    const cx = w/2, cy = h/2 + 10;
    const baseSize = Math.min(w,h) / 260;
    const pulse = 1 + 0.06 * Math.sin(state.scalePulse * Math.PI * 2) * state.scalePulse;

    drawCat(cx, cy, baseSize * pulse);

    // draw hearts on top
    state.hearts.forEach(h => drawHeart(h.x, h.y, h.size, h.life));

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>