<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cute Cat â€” Super Interactive</title>
<style>
  html, body { 
    height: 100%; margin: 0; 
    display: flex; align-items: center; justify-content: center; 
    background: #f7f8fb; 
  }
  canvas { 
    background: transparent; 
    touch-action: none; 
  }
  .ui-hint { 
    position: fixed; left: 12px; bottom: 12px; 
    font-family: system-ui, -apple-system, Segoe UI, Roboto; 
    color: #555; font-size: 14px;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="ui-hint">ðŸ‘† Move mouse/finger â†’ cat looks â€¢ Tap/click â†’ pet the cat ðŸ’–</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  // Responsive canvas resizing
  function resize() {
    const DPR = Math.min(window.devicePixelRatio || 1, 2); // Limit DPR for performance
    const size = Math.min(window.innerWidth, window.innerHeight) * 0.75; // 75% of the smaller dimension
    canvas.width = Math.round(size * DPR); // Canvas width in device pixels
    canvas.height = Math.round(size * DPR); // Canvas height in device pixels
    canvas.style.width = Math.round(size) + 'px'; // CSS width
    canvas.style.height = Math.round(size) + 'px'; // CSS height
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // Apply scaling for high-DPR screens
  }
  window.addEventListener('resize', resize);
  resize(); // Initial call to set up canvas size

  // State variables
  const state = {
    t: 0, // Current time
    cursor: { x: canvas.width / 2, y: canvas.height / 2 }, // Cursor position
  };

  // Get pointer position (mouse or touch)
  function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect(); // Canvas bounding box
    let clientX, clientY;
    if (e.touches && e.touches[0]) {
      clientX = e.touches[0].clientX; // Touch X
      clientY = e.touches[0].clientY; // Touch Y
    } else {
      clientX = e.clientX; // Mouse X
      clientY = e.clientY; // Mouse Y
    }
    return { x: (clientX - rect.left), y: (clientY - rect.top) };
  }

  // Pointer move handler
  function onPointerMove(e) {
    const p = getPointerPos(e);
    state.cursor.x = p.x; // Update cursor X
    state.cursor.y = p.y; // Update cursor Y
  }

  // Draw the cat at the center of the canvas
  function drawCat() {
    const w = canvas.clientWidth; // Canvas width
    const h = canvas.clientHeight; // Canvas height
    const cx = w / 2; // Center X
    const cy = h / 2 + 10; // Center Y (slightly lowered for balance)

    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

    // Draw cat body
    ctx.save();
    ctx.translate(cx, cy); // Translate to center
    ctx.scale(1, 1); // Scale (can be adjusted for animations)

    // Body shape
    ctx.fillStyle = '#f4d9c8';
    ctx.beginPath();
    ctx.ellipse(0, 22, 70, 58, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head shape
    ctx.fillStyle = '#f4d9c8';
    ctx.beginPath();
    ctx.ellipse(0, -38, 60, 54, 0, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(-20, -50, 16, 10, 0, 0, Math.PI * 2); // Left eye
    ctx.ellipse(20, -50, 16, 10, 0, 0, Math.PI * 2); // Right eye
    ctx.fill();

    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(-20, -50, 5, 0, Math.PI * 2); // Left pupil
    ctx.arc(20, -50, 5, 0, Math.PI * 2); // Right pupil
    ctx.fill();

    // Nose
    ctx.fillStyle = '#f08b86';
    ctx.beginPath();
    ctx.ellipse(0, -38, 6, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore(); // Restore canvas state
  }

  // Animation loop
  function frame() {
    drawCat(); // Draw the cat
    requestAnimationFrame(frame); // Queue next frame
  }
  frame(); // Start the animation loop

  // Pointer event listeners
  canvas.addEventListener('mousemove', onPointerMove);
  canvas.addEventListener('touchmove', onPointerMove, { passive: false });
})();
</script>
</body>
</html>