<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Meow Mayhem üòº</title>
<style>
  html, body { margin:0; padding:0; height:100%; background:#0e0f13; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; }
  #ui { position:fixed; inset:0; pointer-events:none; }
  .topbar { display:flex; gap:16px; align-items:center; padding:10px 12px; font-weight:700; text-shadow:0 2px 6px rgba(0,0,0,.5); }
  .pill { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); backdrop-filter: blur(4px); }
  .score { display:flex; gap:8px; align-items:center; }
  .pchip { padding:4px 8px; border-radius:999px; font-size:14px; font-weight:800; }
  .p1 { background:#ff9aa2; color:#2a1a1d; }
  .p2 { background:#9ad1ff; color:#121a24; }
  .p3 { background:#b5ff9a; color:#0f1a10; }
  .p4 { background:#ffdf9a; color:#1a160f; }
  .p5 { background:#c4a2ff; color:#1a1024; }
  .ctr { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); text-align:center; }
  .btn { display:inline-block; padding:12px 18px; border-radius:12px; background:#2c2f3a; color:#fff; font-weight:800; letter-spacing:.3px; cursor:pointer; box-shadow:0 6px 20px rgba(0,0,0,.35); }
  .btn:active { transform:translate(-50%,-48%); }
  .hint { opacity:.8; margin-top:8px; font-size:14px; }
  canvas { display:block; width:100vw; height:100vh; }
  .bottom { position:fixed; bottom:10px; left:50%; transform:translateX(-50%); font-size:13px; opacity:.8; }
  .powerups { position:fixed; top:50px; right:10px; display:flex; flex-direction:column; gap:8px; align-items:flex-end; }
  .powerup { display:flex; gap:4px; align-items:center; padding:4px 8px; border-radius:8px; background:rgba(255,255,255,.1); font-size:13px; }
  .powerup-icon { font-size:20px; }
  .timer { position:fixed; top:10px; right:10px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); backdrop-filter:blur(4px); font-weight:700; }
  
  /* Night mode animation */
  @keyframes nightPulse {
    0% { background-color: rgba(0,0,40,.3); }
    50% { background-color: rgba(0,0,60,.4); }
    100% { background-color: rgba(0,0,40,.3); }
  }
  .night-mode { position:fixed; inset:0; pointer-events:none; background-color: rgba(0,0,40,.3); z-index:10; animation: nightPulse 5s infinite; }
  
  /* Secret sauce animation */
  @keyframes secretSauceWarning {
    0% { background-color: rgba(255,0,0,.0); }
    50% { background-color: rgba(255,0,0,.15); }
    100% { background-color: rgba(255,0,0,.0); }
  }
  .warning { animation: secretSauceWarning 1s infinite; position:fixed; inset:0; pointer-events:none; z-index:11; }
  
  /* Eating animation */
  @keyframes eatingPulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.7; }
    100% { transform: scale(0.1); opacity: 0; }
  }
  .eating { animation: eatingPulse 1s forwards; }
  
  /* Player cat images */
  .cat-img {
    position: absolute;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    object-fit: cover;
    border-radius: 50%;
  }

  /* Sound controls */
  .sound-control {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(255,255,255,0.1);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 100;
    font-size: 20px;
    pointer-events: auto;
    transition: background-color 0.3s;
  }
  
  .sound-control:hover {
    background: rgba(255,255,255,0.2);
  }

  /* Victory Animation */
  @keyframes flyAcross {
    0% { transform: translate(-100%, -50%); }
    100% { transform: translate(100vw, -50%); }
  }

  .victory-animation {
    position: fixed;
    top: 50%;
    left: 0;
    width: 200px;
    height: 100px;
    z-index: 20;
    animation: flyAcross 3s linear;
    pointer-events: none;
  }

  /* Confetti for victory */
  .confetti {
    position: fixed;
    width: 10px;
    height: 10px;
    z-index: 19;
    pointer-events: none;
    animation: confetti-fall linear forwards;
  }

  @keyframes confetti-fall {
    0% { transform: translateY(-10px) rotate(0deg); opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
  }

  /* Crown for winner */
  .crown {
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 24px;
    z-index: 21;
    filter: drop-shadow(0 0 5px gold);
  }

  /* Volume slider popup */
  .volume-popup {
    position: fixed;
    top: 55px;
    left: 10px;
    background: rgba(40,40,50,0.9);
    padding: 10px;
    border-radius: 10px;
    z-index: 101;
    display: none;
    width: 150px;
  }

  .volume-slider {
    width: 100%;
    cursor: pointer;
  }

  .volume-label {
    display: block;
    text-align: center;
    margin-bottom: 5px;
    font-size: 14px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div class="topbar">
    <div class="pill">üòº <strong>Meow Mayhem</strong></div>
    <div id="scores" class="score"></div>
    <div class="pill" id="status"></div>
  </div>
  <div id="center" class="ctr">
    <div style="font-size:42px; font-weight:900; margin-bottom:10px;">Meow Mayhem üòº</div>
    <div style="font-size:18px; opacity:.9; margin-bottom:20px;">Collect üêü. Bonk friends. Avoid chaos. First to <span id="targetPts">30</span> wins.</div>
    <div class="btn" id="startBtn">Press ENTER or Click to Start</div>
    <div class="hint">P1: WASD + F ‚Ä¢ P2: Arrows + / ‚Ä¢ (Enable up to 5 players in code)</div>
  </div>
  <div id="powerups" class="powerups"></div>
  <div id="timer" class="timer">Chaos in: 30s</div>
  <div class="bottom">Pause: <b>P</b> ‚Ä¢ Restart: <b>R</b></div>
</div>
<div id="nightMode" class="night-mode" style="display:none;"></div>
<div id="warning" class="warning" style="display:none;"></div>

<!-- Sound control button -->
<div class="sound-control" id="soundToggle">üîä</div>
<div class="volume-popup" id="volumePopup">
  <span class="volume-label">Volume: 100%</span>
  <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="100">
</div>

<!-- Cat images container (will be dynamically populated) -->
<div id="catImagesContainer" style="position:absolute; top:0; left:0; pointer-events:none;"></div>

<!-- Audio elements with GitHub-hosted sound files -->
<audio id="meowSound" preload="auto" src="sounds/meow.mp3"></audio>
<audio id="superMeowSound" preload="auto" src="sounds/supermeow.mp3"></audio>
<audio id="rumbaSoundLoop" preload="auto" loop src="sounds/roomba.mp3"></audio>
<audio id="dogeSound" preload="auto" src="sounds/doge.mp3"></audio>
<audio id="treatSound" preload="auto" src="sounds/treat.mp3"></audio>
<audio id="laserSound" preload="auto" src="sounds/laser.mp3"></audio>
<audio id="chaosSound" preload="auto" src="sounds/chaos.mp3"></audio>
<audio id="winSound" preload="auto" src="sounds/win.mp3"></audio>

<!-- Victory animation container -->
<div id="victoryContainer" style="display:none; position:fixed; inset:0; z-index:15; pointer-events:none;"></div>

<script>
(() => {
  // ======== CONFIG ========
  const CONFIG = {
    targetScore: 30, // Increased from 10 to 30
    maxPlayers: 2, // Change to 3, 4, or 5 if you want more local players
    playerRadius: 25,
    playerSpeed: 2.4,
    friction: 0.86,
    meowCooldownMs: 1100,
    meowKnockRange: 140, // Increased from 95
    meowKnockForce: 9.5, // Increased from 5.5
    meowParticles: 12, // Particles count
    treatRadius: 10,
    treatsOnField: 6,
    treatRespawnMs: 1600,
    dogeEveryMs: 9000,
    dogeSpeed: 2.0, // Speed for doge to chase player (slightly slower than player)
    dogeEatTimeMs: 1000, // How long the eating animation takes
    roombas: 2,
    laserCount: 5,
    laserActive: true,
    laserInvertMs: 2000,
    boundsPadding: 8,
    powerUpChance: 0.004, // Chance per frame to spawn a power-up
    weatherEvents: true, // Enable/disable weather events
    weatherDuration: 8000, // Weather event duration in ms (8 seconds)
    weatherCooldown: 5000, // Time between weather events (reduced to 5 seconds)
    secretSauceInterval: 30000, // Chaos mode every 30 seconds
    secretSauceDuration: 8000, // How long chaos mode lasts (8 seconds)
    soundEnabled: true, // Sound effects on by default
    masterVolume: 1.0, // Master volume (0.0 to 1.0)
  };

  // ======== SOUND MANAGER ========
  const SoundManager = {
    sounds: {
      meow: document.getElementById('meowSound'),
      superMeow: document.getElementById('superMeowSound'),
      roomba: document.getElementById('rumbaSoundLoop'),
      doge: document.getElementById('dogeSound'),
      treat: document.getElementById('treatSound'),
      laser: document.getElementById('laserSound'),
      chaos: document.getElementById('chaosSound'),
      win: document.getElementById('winSound')
    },

    init() {
      // Set up sound toggle
      const soundToggle = document.getElementById('soundToggle');
      const volumePopup = document.getElementById('volumePopup');
      const volumeSlider = document.getElementById('volumeSlider');
      const volumeLabel = document.querySelector('.volume-label');

      // Toggle sound on/off
      soundToggle.addEventListener('click', () => {
        CONFIG.soundEnabled = !CONFIG.soundEnabled;
        soundToggle.textContent = CONFIG.soundEnabled ? 'üîä' : 'üîá';
        
        if (CONFIG.soundEnabled) {
          // Show volume popup when enabling sound
          volumePopup.style.display = 'block';
          setTimeout(() => {
            volumePopup.style.display = 'none';
          }, 5000); // Hide after 5 seconds
        } else {
          // Stop all sounds when muting
          this.stopAll();
          volumePopup.style.display = 'none';
        }
      });

      // Long press to show volume slider
      let pressTimer;
      soundToggle.addEventListener('mousedown', () => {
        pressTimer = setTimeout(() => {
          volumePopup.style.display = volumePopup.style.display === 'block' ? 'none' : 'block';
        }, 500);
      });
      soundToggle.addEventListener('mouseup', () => {
        clearTimeout(pressTimer);
      });
      soundToggle.addEventListener('mouseleave', () => {
        clearTimeout(pressTimer);
      });

      // Volume control
      volumeSlider.addEventListener('input', () => {
        const volume = volumeSlider.value / 100;
        CONFIG.masterVolume = volume;
        volumeLabel.textContent = `Volume: ${volumeSlider.value}%`;
        
        // Update all sound volumes
        Object.values(this.sounds).forEach(sound => {
          sound.volume = volume;
        });
      });

      // Click outside to close volume popup
      document.addEventListener('click', (e) => {
        if (e.target !== volumePopup && e.target !== soundToggle && !volumePopup.contains(e.target)) {
          volumePopup.style.display = 'none';
        }
      });

      // Set initial volume for all sounds
      Object.values(this.sounds).forEach(sound => {
        sound.volume = CONFIG.masterVolume;
      });
      
      console.log("Sound manager initialized with sounds:", Object.keys(this.sounds));
    },

    play(soundName, options = {}) {
      if (!CONFIG.soundEnabled) return;
      
      const sound = this.sounds[soundName];
      if (!sound) {
        console.warn(`Sound "${soundName}" not found`);
        return;
      }
      
      console.log(`Playing sound: ${soundName}`);
      
      // If the sound is already playing, create a new audio element for overlapping sounds
      if (!options.overlap && !sound.paused && sound.currentTime > 0) {
        return;
      }
      
      if (options.overlap) {
        // Create a temporary clone for overlapping sounds
        const tempSound = sound.cloneNode();
        tempSound.volume = CONFIG.masterVolume;
        tempSound.play().catch(e => console.warn('Error playing sound:', e));
        // Remove after playing to avoid memory leaks
        tempSound.onended = () => tempSound.remove();
      } else {
        // Normal playback
        sound.currentTime = 0;
        sound.play().catch(e => console.warn('Error playing sound:', e));
      }
    },
    
    // Play a sound for a specific duration (for animations)
    playForDuration(soundName, duration, options = {}) {
      if (!CONFIG.soundEnabled) return;
      
      const sound = this.sounds[soundName];
      if (!sound) {
        console.warn(`Sound "${soundName}" not found`);
        return;
      }
      
      console.log(`Playing sound ${soundName} for ${duration}ms`);
      
      // Create a temporary clone for the duration-based sound
      const tempSound = sound.cloneNode();
      tempSound.volume = CONFIG.masterVolume;
      
      // Play the sound
      tempSound.play().catch(e => console.warn('Error playing sound:', e));
      
      // Set up a timer to fade out and stop the sound after the specified duration
      if (duration) {
        const fadeTime = Math.min(1000, duration * 0.2); // 20% of duration for fade out, max 1 second
        
        // Set timeout to start fade out
        setTimeout(() => {
          // Fade out volume gradually
          let startVolume = tempSound.volume;
          const fadeInterval = setInterval(() => {
            if (tempSound.volume > 0.05) {
              tempSound.volume -= 0.05;
            } else {
              clearInterval(fadeInterval);
              tempSound.pause();
              tempSound.remove(); // Clean up the element
            }
          }, fadeTime / 20);
        }, duration - fadeTime);
        
        // Backup cleanup after full duration
        setTimeout(() => {
          tempSound.pause();
          tempSound.remove();
        }, duration + 100);
      }
    },
    
    loop(soundName) {
      if (!CONFIG.soundEnabled) return;
      
      const sound = this.sounds[soundName];
      if (!sound) {
        console.warn(`Sound "${soundName}" not found`);
        return;
      }
      
      console.log(`Looping sound: ${soundName}`);
      sound.loop = true;
      sound.play().catch(e => console.warn('Error playing sound:', e));
    },
    
    stop(soundName) {
      const sound = this.sounds[soundName];
      if (!sound) return;
      
      sound.pause();
      sound.currentTime = 0;
    },
    
    stopAll() {
      Object.values(this.sounds).forEach(sound => {
        sound.pause();
        sound.currentTime = 0;
      });
    },
    
    adjustVolume(value) {
      CONFIG.masterVolume = Math.max(0, Math.min(1, value));
      
      Object.values(this.sounds).forEach(sound => {
        sound.volume = CONFIG.masterVolume;
      });
    }
  };

  // Cat GIFs for the players
  const CAT_GIFS = [
    "https://media.tenor.com/SuVGs-GL7RoAAAAi/shocked-shocked-cat.gif", // Grumpy
    "https://media.tenor.com/Ym6VeAcZoTcAAAAi/aaaah-cat.gif",          // Nyan
    "https://media.tenor.com/1Z8PTLFT8HUAAAAi/voices-cat.gif",         // Keyboard
    "https://media.tenor.com/T_avUEk3aWwAAAAi/catgroove7tv-catgroove.gif", // Bongo
    "https://media.tenor.com/y-Ew-QGLcpYAAAAi/shrek-cat.gif",          // Shrek Cat
  ];

  const SKINS = [
    { name:"Grumpy", emoji:"üòæ", chip:"p1", color:"#ff9aa2", gifIndex: 0 },
    { name:"Nyan", emoji:"üåà", chip:"p2", color:"#9ad1ff", gifIndex: 1 }, 
    { name:"Keyboard", emoji:"üéπ", chip:"p3", color:"#b5ff9a", gifIndex: 2 },
    { name:"Bongo", emoji:"ü•Å", chip:"p4", color:"#ffdf9a", gifIndex: 3 },
    { name:"Shrek", emoji:"üëπ", chip:"p5", color:"#c4a2ff", gifIndex: 4 },
  ];
  
  // Victory GIFs based on player type
  const VICTORY_GIFS = [
    "https://media.tenor.com/eAKuQI-yYD0AAAAi/gato-cat.gif", // Grumpy
    "https://media.tenor.com/4-5UsuINt9EAAAAi/rainbow-cat-rainbow.gif", // Nyan
    "https://media.tenor.com/AUicYpBbFF8AAAAi/piano-cat.gif", // Keyboard
    "https://media.tenor.com/Sv8-f_Fla2cAAAAi/bongo-cat-drum.gif", // Bongo
    "https://media.tenor.com/JZtOQKh_UmUAAAAi/shrek-cat.gif", // Shrek
  ];
  
  // Power-up types
  const POWERUPS = [
    { name: "Speed Boost", emoji: "‚ö°", color: "#ffff00", duration: 5000, effect: (player) => {
      player.speedBoost = 1.6;
      return () => player.speedBoost = 1.0;
    }},
    { name: "Shield", emoji: "üõ°Ô∏è", color: "#00ffff", duration: 6000, effect: (player) => {
      player.hasShield = true;
      return () => player.hasShield = false;
    }},
    { name: "Giant Mode", emoji: "ü¶ñ", color: "#ff00ff", duration: 7000, effect: (player) => {
      player.r *= 1.6;
      updateCatImageSize(player);
      return () => {
        player.r = CONFIG.playerRadius;
        updateCatImageSize(player);
      };
    }},
    { name: "Super Meow", emoji: "üîä", color: "#ff6600", duration: 8000, effect: (player) => {
      player.superMeow = true;
      return () => player.superMeow = false;
    }},
    { name: "Treat Magnet", emoji: "üß≤", color: "#cc33ff", duration: 10000, effect: (player) => {
      player.treatMagnet = true;
      return () => player.treatMagnet = false;
    }},
  ];
  
  // Weather events
  const WEATHER_EVENTS = [
    { name: "Night Mode", onStart: () => {
        document.getElementById("nightMode").style.display = "block";
        updateStatus("üåô Night Mode - Watch out for invisible obstacles!");
      }, onEnd: () => {
        document.getElementById("nightMode").style.display = "none";
        updateStatus("");
      }
    },
    { name: "Slippery Floor", onStart: () => {
        CONFIG.friction = 0.96;
        updateStatus("üßä Slippery Floor - Hard to control!");
      }, onEnd: () => {
        CONFIG.friction = 0.86;
        updateStatus("");
      }
    },
    { name: "Tornado", onStart: () => {
        spawnTornado();
        updateStatus("üå™Ô∏è Tornado Alert - Run for cover!");
        // Removed tornado sound as requested
      }, onEnd: () => {
        tornado = null;
        updateStatus("");
      }
    },
    { name: "Super Speed", onStart: () => {
        CONFIG.playerSpeed *= 1.5;
        updateStatus("üí® Everyone moves super fast!");
      }, onEnd: () => {
        CONFIG.playerSpeed /= 1.5;
        updateStatus("");
      }
    }
  ];

  // ======== SETUP ========
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const catImagesContainer = document.getElementById('catImagesContainer');
  const victoryContainer = document.getElementById('victoryContainer');
  let W = 0, H = 0;
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize() {
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    catImagesContainer.style.width = W + 'px';
    catImagesContainer.style.height = H + 'px';
  }
  resize();
  window.addEventListener('resize', resize);

  // ======== INPUT ========
  const keys = new Set();
  window.addEventListener('keydown', (e) => { 
    keys.add(e.key); 
    if (e.key === 'Enter') start(); 
    if ([' '].includes(e.key)) e.preventDefault(); 
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key));

  // ======== UTIL ========
  const rnd = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function circleCollide(ax,ay,ar, bx,by,br){ return Math.hypot(ax-bx, ay-by) <= ar+br; }
  function edgeBounce(entity, r){
    if (entity.x < r) { entity.x = r; entity.vx = Math.abs(entity.vx)*0.6; }
    if (entity.x > W - r) { entity.x = W - r; entity.vx = -Math.abs(entity.vx)*0.6; }
    if (entity.y < r) { entity.y = r; entity.vy = Math.abs(entity.vy)*0.6; }
    if (entity.y > H - r) { entity.y = H - r; entity.vy = -Math.abs(entity.vy)*0.6; }
  }

  // ======== ENTITIES ========
  const players = [];
  const treats = [];
  const roombas = [];
  const meowBursts = [];
  const meowParticles = [];
  const powerUps = [];
  let doge = null;
  // Track additional doges during chaos mode
  window.doges = [];
  const lasers = [];
  let tornado = null;
  let currentWeather = null;
  let nextWeatherEvent = 0;
  let nextSecretSauce = 0;
  let secretSauceActive = false;
  let secretSauceCountdown = 30;
  let roombaSound = false; // Track if roomba sound is playing

  // Player controls map
  const CONTROL_SETS = [
    { up:'w', down:'s', left:'a', right:'d', meow:'f' },
    { up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', meow:'/' },
    { up:'i', down:'k', left:'j', right:'l', meow:'h' },
    { up:'t', down:'g', left:'f', right:'h', meow:'y' },
    { up:'8', down:'5', left:'4', right:'6', meow:'0' },
  ];

  // Create confetti for victory animation
  function createConfetti() {
    const colors = ['#ff9aa2', '#9ad1ff', '#b5ff9a', '#ffdf9a', '#c4a2ff'];
    const confettiCount = 100;
    
    for (let i = 0; i < confettiCount; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = `${rnd(0, 100)}%`;
      confetti.style.width = `${rnd(5, 15)}px`;
      confetti.style.height = `${rnd(5, 15)}px`;
      confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.opacity = rnd(0.7, 1);
      confetti.style.animationDuration = `${rnd(2, 5)}s`;
      
      victoryContainer.appendChild(confetti);
    }
    
    // Remove confetti after animation is done
    setTimeout(() => {
      while (victoryContainer.firstChild) {
        victoryContainer.removeChild(victoryContainer.firstChild);
      }
    }, 5000);
  }

  // Show victory animation
  function showVictoryAnimation(player) {
    victoryContainer.innerHTML = '';
    victoryContainer.style.display = 'block';
    
    // Create confetti
    createConfetti();
    
    // Get the corresponding victory GIF based on player skin
    const gifIndex = player.skin.gifIndex;
    const victoryGif = document.createElement('img');
    victoryGif.className = 'victory-animation';
    victoryGif.src = VICTORY_GIFS[gifIndex];
    
    // Add crown to player
    const crown = document.createElement('div');
    crown.className = 'crown';
    crown.textContent = 'üëë';
    if (player.imgElement) {
      player.imgElement.appendChild(crown);
    }
    
    // Add player name to animation
    const nameTag = document.createElement('div');
    nameTag.style.position = 'absolute';
    nameTag.style.bottom = '-25px';
    nameTag.style.left = '50%';
    nameTag.style.transform = 'translateX(-50%)';
    nameTag.style.fontWeight = 'bold';
    nameTag.style.color = 'white';
    nameTag.style.textShadow = '0 0 5px black';
    nameTag.textContent = `${player.name} WINS!`;
    victoryGif.appendChild(nameTag);
    
    victoryContainer.appendChild(victoryGif);
    
    // Play victory sound for the duration of the animation
    SoundManager.playForDuration('win', 5000);
    
    // Hide after animation is complete
    setTimeout(() => {
      victoryContainer.style.display = 'none';
    }, 5000);
  }

  // Create cat image element for a player
  function createCatImage(player) {
    const img = document.createElement('img');
    img.className = 'cat-img';
    img.src = CAT_GIFS[player.skin.gifIndex];
    img.id = `cat-${player.id}`;
    img.style.width = `${player.r * 2}px`;
    img.style.height = `${player.r * 2}px`;
    catImagesContainer.appendChild(img);
    return img;
  }
  
  // Update cat image size (for power-ups, etc.)
  function updateCatImageSize(player) {
    if (player.imgElement) {
      player.imgElement.style.width = `${player.r * 2}px`;
      player.imgElement.style.height = `${player.r * 2}px`;
    }
  }
  
  // Update cat image position
  function updateCatImagePositions() {
    players.forEach(p => {
      if (p && p.imgElement) {
        p.imgElement.style.left = `${p.x}px`;
        p.imgElement.style.top = `${p.y}px`;
        
        // Apply eating animation class if being eaten
        if (p.beingEaten) {
          p.imgElement.classList.add('eating');
        } else {
          p.imgElement.classList.remove('eating');
        }
        
        // Apply shield visual effect
        if (p.hasShield) {
          p.imgElement.style.boxShadow = '0 0 10px 5px rgba(0, 255, 255, 0.7)';
        } else if (p.isBeingMeowed) {
          p.imgElement.style.boxShadow = '0 0 8px 4px rgba(255, 255, 255, 0.6)';
        } else {
          p.imgElement.style.boxShadow = 'none';
        }
      }
    });
  }

  function spawnPlayers(n=CONFIG.maxPlayers){
    // First clean up any existing player images
    while (catImagesContainer.firstChild) {
      catImagesContainer.removeChild(catImagesContainer.firstChild);
    }
    
    players.length = 0;
    for(let i=0;i<n;i++){
      const skin = SKINS[i % SKINS.length];
      const p = {
        id:i,
        name: skin.name,
        emoji: skin.emoji,
        color: skin.color,
        chip: skin.chip,
        skin: skin,
        x: W*(0.2 + 0.2*i),
        y: H*(0.3 + 0.1*i),
        vx:0, vy:0,
        r: CONFIG.playerRadius,
        score:0,
        controls: CONTROL_SETS[i],
        invertUntil:0,
        lastMeow: -9999,
        alive:true,
        isBeingMeowed: false,
        meowEffectUntil: 0,
        speedBoost: 1.0,
        hasShield: false,
        superMeow: false,
        treatMagnet: false,
        activePowerUps: [],
        beingEaten: false,
        eatenUntil: 0,
        respawnPoint: { x: 0, y: 0 }
      };
      
      // Create cat image element
      p.imgElement = createCatImage(p);
      
      players.push(p);
    }
    updateScoreUI();
  }

  function spawnTreat(){
    const t = { 
      id: Math.random().toString(36).substring(2, 15),
      x: rnd(CONFIG.boundsPadding, W-CONFIG.boundsPadding),
      y: rnd(CONFIG.boundsPadding+40, H-CONFIG.boundsPadding),
      r: CONFIG.treatRadius, 
      emoji:'üêü',
      vx: 0,
      vy: 0
    };
    treats.push(t);
  }

  function ensureTreats(){
    while (treats.length < CONFIG.treatsOnField) spawnTreat();
  }

  function spawnRoombas(){
    roombas.length = 0;
    for (let i=0;i<CONFIG.roombas;i++){
      roombas.push({
        x: rnd(60, W-60),
        y: rnd(80, H-60),
        r: 18,
        vx: rnd(-1.4,1.4),
        vy: rnd(-1.4,1.4),
        emoji:'üßπ',
      });
    }
    
    // Start roomba sound if not playing
    if (!roombaSound && roombas.length > 0) {
      roombaSound = true;
      SoundManager.loop('roomba');
    }
  }

  function spawnDoge(){
    const side = Math.random() < 0.5 ? 'L' : 'R';
    doge = {
      x: side==='L' ? -60 : W+60,
      y: rnd(90, H-90),
      r: 26,
      vx: side==='L' ? rnd(2.0,2.5) : rnd(-2.5,-2.0),
      vy: 0,
      emoji:'üê∂',
      ttl: 15000,
      target: null,
      eating: null,
      eatingStartTime: 0
    };
    
    // Play doge sound
    SoundManager.play('doge');
  }

  // Add this new function for spawning a second doge during chaos mode
  function spawnSecondDoge() {
    // Choose opposite side from where standard doge usually spawns
    const side = Math.random() < 0.5 ? 'T' : 'B';
    const secondDoge = {
      id: 'chaos_doge',
      x: side === 'T' ? rnd(60, W-60) : rnd(60, W-60),
      y: side === 'T' ? -60 : H+60,
      r: 30, // Slightly larger
      vx: 0,
      vy: side === 'T' ? rnd(2.0, 2.5) : rnd(-2.5, -2.0),
      emoji: 'üê∫', // Different emoji
      ttl: CONFIG.secretSauceDuration, // Will last the entire chaos mode
      target: null,
      eating: null,
      eatingStartTime: 0,
      isChaosDoge: true // Flag to identify it
    };
    
    // Add to the game world
    window.doges.push(secondDoge);
    
    // Play doge sound
    SoundManager.play('doge');
  }

  function spawnLasers(){
    lasers.length = 0;
    for (let i = 0; i < CONFIG.laserCount; i++) {
      lasers.push({
        id: Math.random().toString(36).substring(2, 15),
        x: rnd(40, W-40),
        y: rnd(90, H-40),
        r: 10,
        emoji: 'üî¥',
        t: Math.floor(rnd(0, 120)),
        targetX: rnd(40, W-40),
        targetY: rnd(90, H-40),
        speed: rnd(2.8, 4.2)
      });
    }
  }
  
  function spawnTornado() {
    tornado = {
      x: rnd(W * 0.25, W * 0.75),
      y: rnd(H * 0.25, H * 0.75),
      r: 50,
      vx: rnd(-2, 2),
      vy: rnd(-2, 2),
      pullForce: 0.4,
      rotationSpeed: 0.1,
      angle: 0,
      particles: []
    };
    
    // Create tornado particles
    for (let i = 0; i < 30; i++) {
      tornado.particles.push({
        x: tornado.x + rnd(-tornado.r, tornado.r),
        y: tornado.y + rnd(-tornado.r, tornado.r),
        size: rnd(4, 10),
        angle: rnd(0, Math.PI * 2),
        distance: rnd(5, tornado.r),
        speed: rnd(0.05, 0.15)
      });
    }
  }
  
  function spawnPowerUp() {
    const type = POWERUPS[Math.floor(Math.random() * POWERUPS.length)];
    const powerUp = {
      x: rnd(CONFIG.boundsPadding * 2, W - CONFIG.boundsPadding * 2),
      y: rnd(CONFIG.boundsPadding * 2 + 40, H - CONFIG.boundsPadding * 2),
      r: 15,
      type: type,
      emoji: type.emoji,
      collectTime: 0,
      collectPlayer: null,
      pulsePhase: 0
    };
    powerUps.push(powerUp);
  }

  // Create particle effect
  function createMeowParticles(x, y, color, count = CONFIG.meowParticles) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = rnd(2, 6);
      meowParticles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: rnd(3, 8),
        color: color,
        life: rnd(30, 80),
        opacity: 1
      });
    }
  }
  
  // Create explosion particles
  function createExplosion(x, y, color, count = 30) {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = rnd(3, 8);
      meowParticles.push({
        x: x,
        y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: rnd(4, 10),
        color: color,
        life: rnd(40, 100),
        opacity: 1
      });
    }
  }
  
  // Respawn a player after being eaten
  function respawnPlayer(player) {
    player.beingEaten = false;
    player.x = player.respawnPoint.x;
    player.y = player.respawnPoint.y;
    player.vx = 0;
    player.vy = 0;
    player.alive = true;
    
    // Remove eating animation from image
    if (player.imgElement) {
      player.imgElement.classList.remove('eating');
    }
    
    // Create respawn particle effect
    createExplosion(player.x, player.y, player.color, 20);
  }

  // ======== GAME LOOP ========
  let running = false;
  let last = performance.now();
  let acc = 0;
  const dt = 1000/60;
  let nextTreatAt = 0;
  let nextDogeAt = 0;

  function start(){
    if (running) return;
    document.getElementById('center').style.display='none';
    document.getElementById('timer').style.display = 'block';
    running = true;
    resetGame();
    last = performance.now();
    requestAnimationFrame(loop);
    
    // Initialize audio with a user gesture
    if (!window.audioInitialized) {
      window.audioInitialized = true;
      console.log("Initializing audio on game start...");
      
      // Play and immediately pause all sounds to initialize the audio context
      Object.values(SoundManager.sounds).forEach(sound => {
        sound.volume = CONFIG.masterVolume;
        const playPromise = sound.play();
        if (playPromise !== undefined) {
          playPromise.then(_ => {
            sound.pause();
            sound.currentTime = 0;
            console.log("Audio initialized successfully");
          }).catch(error => {
            console.log("Audio play prevented: ", error);
          });
        }
      });
      
      updateStatus('Game started! üîä Sound effects enabled.');
      
      // Start roomba sound
      if (roombas.length > 0) {
        roombaSound = true;
        SoundManager.loop('roomba');
      }
    }
  }

  function resetGame(){
    // Initialize sound manager
    if (!window.soundInitialized) {
      SoundManager.init();
      window.soundInitialized = true;
    }
    
    spawnPlayers(CONFIG.maxPlayers);
    treats.length=0;
    roombas.length=0;
    meowBursts.length=0;
    meowParticles.length=0;
    powerUps.length=0;
    doge = null;
    // Reset chaos doges array
    window.doges = [];
    tornado = null;
    currentWeather = null;
    if (CONFIG.laserActive) spawnLasers();
    spawnRoombas();
    for(let i=0;i<CONFIG.treatsOnField;i++) spawnTreat();
    nextTreatAt = performance.now() + CONFIG.treatRespawnMs;
    nextDogeAt = performance.now() + CONFIG.dogeEveryMs;
    nextWeatherEvent = performance.now() + 5000;
    nextSecretSauce = performance.now() + CONFIG.secretSauceInterval;
    secretSauceActive = false;
    secretSauceCountdown = 30;
    document.getElementById('warning').style.display = 'none';
    document.getElementById('nightMode').style.display = 'none';
    winner = null;
    paused = false;
    updateStatus('Collect fish. First to ' + CONFIG.targetScore + '!');
    document.getElementById('powerups').innerHTML = '';
    updateChaosTimer();
    
    // Clean up victory animation
    victoryContainer.style.display = 'none';
    while (victoryContainer.firstChild) {
      victoryContainer.removeChild(victoryContainer.firstChild);
    }
    
    // Remove any crowns from previous winners
    document.querySelectorAll('.crown').forEach(crown => crown.remove());
    
    // Stop all sounds
    SoundManager.stopAll();
    
    // Start roomba sound
    if (roombas.length > 0) {
      roombaSound = true;
      SoundManager.loop('roomba');
    }
  }

  function updateStatus(s){ document.getElementById('status').textContent = s; }
  function updateScoreUI(){
    const el = document.getElementById('scores');
    el.innerHTML = '';
    players.forEach(p=>{
      const span = document.createElement('span');
      span.className = `pchip ${p.chip}`;
      span.textContent = `${p.emoji} ${p.name}: ${p.score}`;
      el.appendChild(span);
    });
    document.getElementById('targetPts').textContent = CONFIG.targetScore;
  }
  
  function updatePowerUpsUI() {
    const el = document.getElementById('powerups');
    el.innerHTML = '';
    
    players.forEach(p => {
      p.activePowerUps.forEach(pu => {
        if (!pu.displayElement) {
          const div = document.createElement('div');
          div.className = 'powerup';
          div.innerHTML = `
            <span class="powerup-icon" style="color:${pu.type.color}">${pu.type.emoji}</span>
            <span>${pu.type.name}: ${p.name}</span>
            <span id="pu-timer-${pu.id}">${Math.ceil((pu.endTime - performance.now())/1000)}s</span>
          `;
          pu.displayElement = div;
          el.appendChild(div);
        } else {
          const timer = document.getElementById(`pu-timer-${pu.id}`);
          if (timer) {
            timer.textContent = `${Math.ceil((pu.endTime - performance.now())/1000)}s`;
          }
        }
      });
    });
  }
  
  function updateChaosTimer() {
    document.getElementById('timer').textContent = `Chaos in: ${secretSauceCountdown}s`;
  }

  let paused = false;
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase()==='p'){ paused = !paused; updateStatus(paused?'Paused':''); }
    if (e.key.toLowerCase()==='r'){ resetGame(); }
  });
  document.getElementById('startBtn').addEventListener('click', start);

  let winner = null;

  function handleInput(p){
    // Skip input handling if player is being eaten
    if (p.beingEaten) return;
    
    const now = performance.now();
    let up = keys.has(p.controls.up) || keys.has(p.controls.up.toUpperCase());
    let down = keys.has(p.controls.down) || keys.has(p.controls.down.toUpperCase());
    let left = keys.has(p.controls.left) || keys.has(p.controls.left.toUpperCase());
    let right = keys.has(p.controls.right) || keys.has(p.controls.right.toUpperCase());

    // Inverted controls if laser-distracted
    if (now < p.invertUntil){ [up,down,left,right] = [down,up,right,left]; }

    const speed = CONFIG.playerSpeed * p.speedBoost;
    if (up) p.vy -= speed*0.6;
    if (down) p.vy += speed*0.6;
    if (left) p.vx -= speed*0.6;
    if (right) p.vx += speed*0.6;

    // Handle meow attack
    const meow = keys.has(p.controls.meow) || keys.has(p.controls.meow.toUpperCase());
    if (meow && now - p.lastMeow > CONFIG.meowCooldownMs) {
      p.lastMeow = now;
      
      // Create meow burst
      const burst = {
        x: p.x,
        y: p.y,
        r: p.superMeow ? CONFIG.meowKnockRange * 1.5 : CONFIG.meowKnockRange,
        player: p,
        t: 0,
        isSuperMeow: p.superMeow
      };
      meowBursts.push(burst);
      
      // Create particle effect
      createMeowParticles(p.x, p.y, p.color, p.superMeow ? CONFIG.meowParticles * 2 : CONFIG.meowParticles);
      
      // Play appropriate meow sound
      SoundManager.play(p.superMeow ? 'superMeow' : 'meow');
    }
  }

  function updatePlayers(){
    const now = performance.now();
    
    // Update active power-ups
    players.forEach(p => {
      // Check for expired power-ups
      for (let i = p.activePowerUps.length - 1; i >= 0; i--) {
        const pu = p.activePowerUps[i];
        if (now >= pu.endTime) {
          // Remove power-up effect
          pu.removeEffect();
          
          // Remove from UI
          if (pu.displayElement && pu.displayElement.parentNode) {
            pu.displayElement.parentNode.removeChild(pu.displayElement);
          }
          
          // Remove from player's active power-ups
          p.activePowerUps.splice(i, 1);
        }
      }
      
      // Handle meow effect visual
      if (now < p.meowEffectUntil) {
        p.isBeingMeowed = true;
      } else {
        p.isBeingMeowed = false;
      }
      
      // Check if player needs to be respawned after being eaten
      if (p.beingEaten && now >= p.eatenUntil) {
        respawnPlayer(p);
      }
      
      // Only handle input and movement if not being eaten
      if (!p.beingEaten) {
        handleInput(p);
        
        // Move player
        p.x += p.vx;
        p.y += p.vy;
        
        // Apply friction
        p.vx *= CONFIG.friction;
        p.vy *= CONFIG.friction;
        
        // Enforce boundaries with bounce effect
        edgeBounce(p, CONFIG.boundsPadding + p.r);
      }
      
      // Magnet effect - pull nearby treats
      if (p.treatMagnet) {
        const magnetRange = 150;
        treats.forEach(treat => {
          const dx = p.x - treat.x;
          const dy = p.y - treat.y;
          const d = Math.hypot(dx, dy);
          
          if (d < magnetRange) {
            const strength = (1 - d / magnetRange) * 2.5;
            treat.vx += (dx / d) * strength;
            treat.vy += (dy / d) * strength;
          }
        });
      }
    });
  }

  function updateTreats(){
    const now = performance.now();
    
    // Update all treats
    treats.forEach(t => {
      // Apply friction
      t.vx *= 0.95;
      t.vy *= 0.95;
      
      // Move treat
      t.x += t.vx;
      t.y += t.vy;
    });
    
    // Check for treat collection
    for (let i = treats.length - 1; i >= 0; i--) {
      const t = treats[i];
      
      for (const p of players) {
        if (p.beingEaten) continue; // Skip if player is being eaten
        
        if (circleCollide(p.x, p.y, p.r, t.x, t.y, t.r)) {
          // Collect treat
          p.score++;
          treats.splice(i, 1);
          updateScoreUI();
          
          // Check for winner
          if (p.score >= CONFIG.targetScore) {
            winner = p;
            showVictoryAnimation(p);
          }
          
          // Create particle effect at collection point
          createExplosion(t.x, t.y, "#ffcc00", 10);
          
          // Play treat collection sound
          SoundManager.play('treat', { overlap: true });
          break;
        }
      }
    }
    
    // Spawn new treats
    if (now >= nextTreatAt) {
      nextTreatAt = now + CONFIG.treatRespawnMs;
      ensureTreats();
    }
  }

  function updateRoombas(){
    roombas.forEach(r => {
      // Move roomba
      r.x += r.vx;
      r.y += r.vy;
      
      // Bounce off edges
      if (r.x < r.r || r.x > W - r.r) {
        r.vx *= -1;
        r.x = clamp(r.x, r.r, W - r.r);
      }
      if (r.y < r.r || r.y > H - r.r) {
        r.vy *= -1;
        r.y = clamp(r.y, r.r, H - r.r);
      }
      
      // Randomly change direction occasionally
      if (Math.random() < 0.01) {
        r.vx += rnd(-0.5, 0.5);
        r.vy += rnd(-0.5, 0.5);
        
        // Normalize speed
        const speed = Math.hypot(r.vx, r.vy);
        if (speed > 1.4) {
          r.vx = (r.vx / speed) * 1.4;
          r.vy = (r.vy / speed) * 1.4;
        }
      }
      
      // Collide with players
      for (const p of players) {
        if (p.beingEaten) continue; // Skip if player is being eaten
        
        if (circleCollide(p.x, p.y, p.r, r.x, r.y, r.r)) {
          // Bump player
          const dx = p.x - r.x;
          const dy = p.y - r.y;
          const d = Math.hypot(dx, dy) || 1;
          
          // Apply force to player
          p.vx += (dx / d) * 4;
          p.vy += (dy / d) * 4;
          
          // Apply opposite force to roomba
          r.vx -= (dx / d) * 2;
          r.vy -= (dy / d) * 2;
        }
      }
    });
  }

  // Update the updateDoge function to handle multiple doges
  function updateDoge() {
    const now = performance.now();
    
    // Spawn regular doge if needed
    if (!doge && now >= nextDogeAt) { 
      nextDogeAt = now + CONFIG.dogeEveryMs;
      spawnDoge(); 
    }
    
    // Process main doge
    if (doge) {
      // If doge is not eating a player, move toward nearest player
      if (!doge.eating) {
        // Find closest player
        let closest = Infinity;
        let closestPlayer = null;
        
        for (const p of players) {
          if (p.beingEaten) continue;
          
          const d = dist(doge, p);
          if (d < closest) {
            closest = d;
            closestPlayer = p;
          }
        }
        
        if (closestPlayer) {
          doge.target = closestPlayer;
          
          // Chase target player
          const dx = closestPlayer.x - doge.x;
          const dy = closestPlayer.y - doge.y;
          const d = Math.hypot(dx, dy) || 1;
          
          doge.vx = (dx / d) * CONFIG.dogeSpeed;
          doge.vy = (dy / d) * CONFIG.dogeSpeed;
        }
        
        // Move doge
        doge.x += doge.vx;
        doge.y += doge.vy;
        
        // Check if caught a player
        for (const p of players) {
          if (p.beingEaten) continue;
          
          if (circleCollide(p.x, p.y, p.r, doge.x, doge.y, doge.r)) {
            // Start eating player
            doge.eating = p;
            doge.eatingStartTime = now;
            
            // Mark player as being eaten
            p.beingEaten = true;
            p.eatenUntil = now + CONFIG.dogeEatTimeMs;
            
            // Set respawn point
            p.respawnPoint = {
              x: rnd(100, W-100),
              y: rnd(100, H-100)
            };
            
            // Eating effect
            createExplosion(p.x, p.y, "#ff6600", 25);
            
            // Player loses treats
            if (p.score > 0) {
              const lostTreats = Math.min(p.score, 3);
              p.score -= lostTreats;
              updateScoreUI();
              
              // Spawn lost treats
              for (let i = 0; i < lostTreats; i++) {
                treats.push({
                  x: doge.x + rnd(-60, 60),
                  y: doge.y + rnd(-60, 60),
                  r: CONFIG.treatRadius,
                  emoji: 'üêü',
                  vx: rnd(-3, 3),
                  vy: rnd(-3, 3)
                });
              }
            }
            
            updateStatus(`${p.name} got eaten by doge!`);
            SoundManager.play('doge');
            break;
          }
        }
      } else {
        // Check if done eating
        const eatingDuration = now - doge.eatingStartTime;
        if (eatingDuration >= CONFIG.dogeEatTimeMs) {
          doge.eating = null;
        }
      }
      
      // Decrement TTL
      doge.ttl -= 16;
      
      // Remove doge if expired or off screen
      if (doge.ttl <= 0 || 
          doge.x < -80 || 
          doge.x > W+80 || 
          doge.y < -80 || 
          doge.y > H+80) {
        doge = null;
      }
    }
    
    // Process additional doges during chaos mode
    if (window.doges && window.doges.length > 0) {
      for (let i = window.doges.length - 1; i >= 0; i--) {
        const chaosDoge = window.doges[i];
        
        // Chase closest player
        let closestDist = Infinity;
        let closestPlayer = null;
        
        for (const p of players) {
          if (p.beingEaten) continue;
          
          const d = Math.hypot(p.x - chaosDoge.x, p.y - chaosDoge.y);
          if (d < closestDist) {
            closestDist = d;
            closestPlayer = p;
          }
        }
        
        // Move toward closest player
        if (closestPlayer) {
          const dx = closestPlayer.x - chaosDoge.x;
          const dy = closestPlayer.y - chaosDoge.y;
          const d = Math.hypot(dx, dy) || 1;
          
          // Slightly faster than regular doge
          chaosDoge.vx = (dx/d) * CONFIG.dogeSpeed * 1.2;
          chaosDoge.vy = (dy/d) * CONFIG.dogeSpeed * 1.2;
          
          // Check if caught a player
          for (const p of players) {
            if (p.beingEaten) continue;
            
            if (circleCollide(p.x, p.y, p.r, chaosDoge.x, chaosDoge.y, chaosDoge.r)) {
              // Start eating player
              chaosDoge.eating = p;
              chaosDoge.eatingStartTime = now;
              
              // Mark player as being eaten
              p.beingEaten = true;
              p.eatenUntil = now + CONFIG.dogeEatTimeMs;
              
              // Set respawn point
              p.respawnPoint = {
                x: rnd(100, W-100),
                y: rnd(100, H-100)
              };
              
              // Eating effect
              createExplosion(p.x, p.y, "#ff6600", 25);
              
              // Player loses treats
              if (p.score > 0) {
                const lostTreats = Math.min(p.score, 5); // Chaos doge takes more treats!
                p.score -= lostTreats;
                updateScoreUI();
                
                // Spawn lost treats
                                for (let j = 0; j < lostTreats; j++) {
                  treats.push({
                    x: chaosDoge.x + rnd(-60, 60),
                    y: chaosDoge.y + rnd(-60, 60),
                    r: CONFIG.treatRadius,
                    emoji: 'üêü',
                    vx: rnd(-3, 3),
                    vy: rnd(-3, 3)
                  });
                }
              }
              
              updateStatus(`CHAOS DOGE devoured ${p.name}!`);
              SoundManager.play('doge');
              break;
            }
          }
        }
        
        // Update position
        if (!chaosDoge.eating) {
          chaosDoge.x += chaosDoge.vx;
          chaosDoge.y += chaosDoge.vy;
        } else {
          // Check if done eating
          const eatingDuration = now - chaosDoge.eatingStartTime;
          if (eatingDuration >= CONFIG.dogeEatTimeMs) {
            chaosDoge.eating = null;
          }
        }
        
        // Decrease TTL
        chaosDoge.ttl -= 16;
        
        // Remove if expired
        if (chaosDoge.ttl <= 0 || 
            chaosDoge.x < -80 || 
            chaosDoge.x > W+80 || 
            chaosDoge.y < -80 || 
            chaosDoge.y > H+80 ||
            !secretSauceActive) { // Remove when chaos mode ends
          window.doges.splice(i, 1);
        }
      }
    }
  }

  function updateLasers(){
    if (!CONFIG.laserActive) return;
    
    lasers.forEach(l => {
      l.t += 1;
      
      // Change target occasionally
      if (l.t % 120 === 0) {
        l.targetX = rnd(40, W-40);
        l.targetY = rnd(90, H-40);
      }
      
      // Move toward target
      const dx = l.targetX - l.x;
      const dy = l.targetY - l.y;
      const d = Math.hypot(dx, dy);
      
      if (d > 5) {
        l.x += (dx/d) * l.speed;
        l.y += (dy/d) * l.speed;
      }
      
      // Check for player collisions
      for (const p of players) {
        if (p.beingEaten) continue; // Skip if player is being eaten
        
        if (circleCollide(p.x, p.y, p.r, l.x, l.y, l.r)) {
          // Invert controls
          p.invertUntil = performance.now() + CONFIG.laserInvertMs;
          
          // Move laser away
          l.targetX = rnd(40, W-40);
          l.targetY = rnd(90, H-40);
          
          // Create particle effect
          createExplosion(l.x, l.y, "#ff0000", 15);
          
          // Play laser sound
          SoundManager.play('laser');
          
          updateStatus(`${p.name} got confused by a laser!`);
        }
      }
    });
  }

  function updateMeowBursts(){
    const now = performance.now();
    
    // Update existing bursts
    for (let i = meowBursts.length - 1; i >= 0; i--) {
      const burst = meowBursts[i];
      
      burst.t += 1;
      
      // Check for collisions with other players
      for (const p of players) {
        if (p.beingEaten) continue; // Skip if player is being eaten
        if (p === burst.player) continue; // Skip the meowing player
        if (p.hasShield) continue; // Skip players with shield
        
        // Check if player is within burst radius
        const d = dist(p, burst);
        if (d <= burst.r) {
          // Calculate knock direction
          const angle = Math.atan2(p.y - burst.y, p.x - burst.x);
          const knockPower = burst.isSuperMeow ? CONFIG.meowKnockForce * 1.5 : CONFIG.meowKnockForce;
          
          // Apply knockback
          p.vx += Math.cos(angle) * knockPower * (1 - d/burst.r);
          p.vy += Math.sin(angle) * knockPower * (1 - d/burst.r);
          
          // Set meow effect
          p.meowEffectUntil = now + 300;
          
          // Add particles at the collision point
          createMeowParticles(p.x, p.y, burst.player.color, 6);
        }
      }
      
      // Remove old bursts
      if (burst.t > 5) {
        meowBursts.splice(i, 1);
      }
    }
    
    // Update meow particles
    for (let i = meowParticles.length - 1; i >= 0; i--) {
      const p = meowParticles[i];
      
      // Move particle
      p.x += p.vx;
      p.y += p.vy;
      
      // Slow down
      p.vx *= 0.95;
      p.vy *= 0.95;
      
      // Decrease life and opacity
      p.life -= 1;
      p.opacity = p.life / 80;
      
      // Remove dead particles
      if (p.life <= 0) {
        meowParticles.splice(i, 1);
      }
    }
  }
  
  function updatePowerUps() {
    const now = performance.now();
    
    // Random chance to spawn a power-up
    if (Math.random() < CONFIG.powerUpChance) {
      spawnPowerUp();
    }
    
    // Check for power-up collection
    for (let i = powerUps.length - 1; i >= 0; i--) {
      const pu = powerUps[i];
      
      // Skip if already collected
      if (pu.collectPlayer) continue;
      
      // Check for collision with players
      for (const p of players) {
        if (p.beingEaten) continue; // Skip if player is being eaten
        
        if (circleCollide(p.x, p.y, p.r, pu.x, pu.y, pu.r)) {
          // Mark as collected
          pu.collectPlayer = p;
          pu.collectTime = now;
          
          // Apply power-up effect
          const powerUpId = Math.random().toString(36).substring(2, 9);
          const removeEffect = pu.type.effect(p);
          
          // Add to player's active power-ups
          p.activePowerUps.push({
            id: powerUpId,
            type: pu.type,
            endTime: now + pu.type.duration,
            removeEffect: removeEffect,
            displayElement: null
          });
          
          // Create particle effect
          createExplosion(pu.x, pu.y, pu.type.color, 20);
          
          updateStatus(`${p.name} collected ${pu.type.name}!`);
          break;
        }
      }
      
      // Remove collected power-ups after animation
      if (pu.collectPlayer && now - pu.collectTime > 500) {
        powerUps.splice(i, 1);
      }
      
      // Pulse animation
      pu.pulsePhase = (pu.pulsePhase + 0.05) % (Math.PI * 2);
    }
    
    // Update power-ups UI
    updatePowerUpsUI();
  }
  
  function updateTornado() {
    if (!tornado) return;
    
    // Move tornado
    tornado.x += tornado.vx;
    tornado.y += tornado.vy;
    
    // Bounce off edges
    if (tornado.x < tornado.r || tornado.x > W - tornado.r) {
      tornado.vx *= -1;
      tornado.x = clamp(tornado.x, tornado.r, W - tornado.r);
    }
    if (tornado.y < tornado.r || tornado.y > H - tornado.r) {
      tornado.vy *= -1;
      tornado.y = clamp(tornado.y, tornado.r, H - tornado.r);
    }
    
    // Randomly change direction occasionally
    if (Math.random() < 0.02) {
      tornado.vx += rnd(-0.5, 0.5);
      tornado.vy += rnd(-0.5, 0.5);
      
      // Limit max speed
      const speed = Math.hypot(tornado.vx, tornado.vy);
      if (speed > 3) {
        tornado.vx = (tornado.vx / speed) * 3;
        tornado.vy = (tornado.vy / speed) * 3;
      }
    }
    
    // Update tornado particles
    tornado.angle += tornado.rotationSpeed;
    
    tornado.particles.forEach(p => {
      // Update angle
      p.angle += p.speed;
      
      // Calculate position
      p.x = tornado.x + Math.cos(p.angle) * p.distance;
      p.y = tornado.y + Math.sin(p.angle) * p.distance;
    });
    
    // Pull players toward tornado
    for (const p of players) {
      if (p.beingEaten) continue; // Skip if player is being eaten
      
      const dx = tornado.x - p.x;
      const dy = tornado.y - p.y;
      const d = Math.hypot(dx, dy);
      
      const pullRadius = tornado.r * 4;
      
      if (d < pullRadius) {
        // Calculate pull strength based on distance
        const pullStrength = tornado.pullForce * (1 - d / pullRadius);
        
        // Apply force toward tornado
        p.vx += (dx / d) * pullStrength;
        p.vy += (dy / d) * pullStrength;
        
        // Spin effect for very close players
        if (d < tornado.r * 1.5) {
          const spinAngle = Math.atan2(dy, dx) + Math.PI/2;
          p.vx += Math.cos(spinAngle) * pullStrength * 0.8;
          p.vy += Math.sin(spinAngle) * pullStrength * 0.8;
        }
      }
    }
  }
  
  function updateWeather() {
    const now = performance.now();
    
    // Start new weather event
    if (!currentWeather && CONFIG.weatherEvents && now >= nextWeatherEvent) {
      // Choose random weather event
      const event = WEATHER_EVENTS[Math.floor(Math.random() * WEATHER_EVENTS.length)];
      currentWeather = {
        type: event,
        startTime: now,
        endTime: now + CONFIG.weatherDuration
      };
      
      // Start weather effect
      event.onStart();
      
      // Set next weather event time
      nextWeatherEvent = now + CONFIG.weatherDuration + CONFIG.weatherCooldown;
    }
    
    // End current weather event
    if (currentWeather && now >= currentWeather.endTime) {
      currentWeather.type.onEnd();
      currentWeather = null;
    }
  }

  function updateSecretSauce() {
    const now = performance.now();
    
    // Update countdown
    if (!secretSauceActive) {
      secretSauceCountdown = Math.max(0, Math.floor((nextSecretSauce - now) / 1000));
      updateChaosTimer();
    }
    
    // Start secret sauce mode
    if (!secretSauceActive && now >= nextSecretSauce) {
      secretSauceActive = true;
      document.getElementById('warning').style.display = 'block';
      updateStatus('‚ö†Ô∏è CHAOS MODE ACTIVATED! ‚ö†Ô∏è');
      document.getElementById('timer').textContent = 'CHAOS MODE!';
      
      // Play chaos sound for the duration of the mode
      SoundManager.playForDuration('chaos', CONFIG.secretSauceDuration);
      
      // Spawn additional chaos
      for (let i = 0; i < 3; i++) spawnPowerUp();
      
      // Spawn a doge if one doesn't exist
      if (!doge) {
        spawnDoge();
      }
      
      // CHANGE: Always spawn an additional doge during chaos mode
      spawnSecondDoge();
      
      for (let i = 0; i < 3; i++) spawnTreat();
    }
    
    // End secret sauce mode
    if (secretSauceActive && now >= nextSecretSauce + CONFIG.secretSauceDuration) {
      secretSauceActive = false;
      document.getElementById('warning').style.display = 'none';
      updateStatus('Chaos mode ended!');
      nextSecretSauce = now + CONFIG.secretSauceInterval;
      secretSauceCountdown = Math.floor(CONFIG.secretSauceInterval / 1000);
      updateChaosTimer();
    }
  }

  function update(){
    updatePlayers();
    updateTreats();
    updateRoombas();
    updateDoge();
    updateLasers();
    updateMeowBursts();
    updatePowerUps();
    updateWeather();
    updateTornado();
    updateSecretSauce();
    
    // Update cat image positions
    updateCatImagePositions();
    
    // Update status if someone's winning
    const leader = players.reduce((a, b) => a.score > b.score ? a : b);
    if (leader.score >= CONFIG.targetScore * 0.75 && !winner) {
      updateStatus(`${leader.name} is in the lead with ${leader.score}/${CONFIG.targetScore}!`);
    }
  }

  // ======== RENDERING ========
  function drawCircle(x, y, r, fill, stroke) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, 2 * Math.PI);
    if (fill) { ctx.fillStyle = fill; ctx.fill(); }
    if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke(); }
  }

  function render(){
    // Clear canvas
    ctx.clearRect(0, 0, W, H);
    
    // Draw treats
    for (const t of treats) {
      ctx.font = '16px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(t.emoji, t.x, t.y);
    }
    
    // Draw meow particles
    for (const p of meowParticles) {
      ctx.globalAlpha = p.opacity;
      drawCircle(p.x, p.y, p.r, p.color);
      ctx.globalAlpha = 1;
    }
    
    // Draw power-ups
    for (const pu of powerUps) {
      if (pu.collectPlayer) {
        // Collection animation
        const elapsed = performance.now() - pu.collectTime;
        const scale = 1 + elapsed / 100;
        const opacity = 1 - elapsed / 500;
        
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.translate(pu.x, pu.y);
        ctx.scale(scale, scale);
        
        // Glow effect
        ctx.shadowColor = pu.type.color;
        ctx.shadowBlur = 10;
        
        ctx.font = '20px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(pu.type.emoji, 0, 0);
        
        ctx.restore();
      } else {
        // Normal display with pulse effect
        const pulse = Math.sin(pu.pulsePhase) * 0.2 + 1;
        
        ctx.save();
        ctx.translate(pu.x, pu.y);
        ctx.scale(pulse, pulse);
        
        // Glow effect
        ctx.shadowColor = pu.type.color;
        ctx.shadowBlur = 8;
        
        ctx.font = '20px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(pu.type.emoji, 0, 0);
        
        ctx.restore();
      }
    }
    
    // Draw meow bursts
    for (const burst of meowBursts) {
      const progress = burst.t / 5; // 0 to 1 over 5 frames
      const radius = burst.r * progress;
      const alpha = 1 - progress;
      
      ctx.globalAlpha = alpha * 0.4;
      drawCircle(burst.x, burst.y, radius, burst.player.color);
      ctx.globalAlpha = 1;
    }
    
    // Draw roombas
    for (const r of roombas) {
      drawCircle(r.x, r.y, r.r, '#5d4037', '#3e2723');
      ctx.font = '16px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(r.emoji, r.x, r.y);
    }
    
    // Draw doge
    if (doge) {
      // Draw differently if eating a player
      if (doge.eating) {
        // Larger mouth effect
        drawCircle(doge.x, doge.y, doge.r + 5, '#4a1f1f', '#7a3f3f');
        
        // Blood effect
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(doge.x, doge.y, doge.r - 5, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
        
        // Doge emoji
        ctx.font = '25px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('üê∂', doge.x, doge.y);
      } else {
        drawCircle(doge.x, doge.y, doge.r, '#4a1f1f', '#7a3f3f');
        ctx.font = '20px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('üê∂', doge.x, doge.y);
      }
    }
    
    // Chaos doges
    if (window.doges && window.doges.length > 0) {
      for (const chaosDoge of window.doges) {
        // Red glow effect
        ctx.save();
        ctx.globalAlpha = 0.3;
        drawCircle(chaosDoge.x, chaosDoge.y, chaosDoge.r+10, '#ff0000', null);
        ctx.restore();
        
        // Draw differently if eating a player
        if (chaosDoge.eating) {
          // Larger mouth effect
          drawCircle(chaosDoge.x, chaosDoge.y, chaosDoge.r + 8, '#4a1f1f', '#7a3f3f');
          
          // Blood effect
          ctx.save();
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = '#ff0000';
          ctx.beginPath();
          ctx.arc(chaosDoge.x, chaosDoge.y, chaosDoge.r - 5, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
          
          // Wolf emoji
          ctx.font = '30px system-ui';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText('üê∫', chaosDoge.x, chaosDoge.y);
        } else {
          drawCircle(chaosDoge.x, chaosDoge.y, chaosDoge.r, '#4a1f1f', '#7a3f3f');
          ctx.font = '25px system-ui';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText('üê∫', chaosDoge.x, chaosDoge.y);
        }
      }
    }
    
    // Draw lasers
    for (const l of lasers) {
      // Pulse effect
      const pulse = Math.sin(l.t * 0.2) * 0.2 + 1;
      
      ctx.save();
      ctx.translate(l.x, l.y);
      ctx.scale(pulse, pulse);
      
      // Glow effect
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 15;
      
      ctx.font = '16px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(l.emoji, 0, 0);
      
      ctx.restore();
    }
    
    // Draw tornado
    if (tornado) {
      // Draw tornado particles
      ctx.save();
      for (const p of tornado.particles) {
        ctx.fillStyle = `rgba(100, 100, 100, ${Math.random() * 0.4 + 0.4})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
      
      // Draw tornado emoji
      ctx.font = '40px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('üå™Ô∏è', tornado.x, tornado.y);
    }
  }

  function loop(now){
    if (!running) return;
    
    // Winner found, stop game after delay
    if (winner && now - winner.winTime > 6000) {
      running = false;
      document.getElementById('center').style.display = 'block';
      document.getElementById('timer').style.display = 'none';
      return;
    }
    
    // Set win time when winner is found
    if (winner && !winner.winTime) {
      winner.winTime = now;
    }
    
    // Handle pause
    if (paused) {
      last = now;
      requestAnimationFrame(loop);
      return;
    }
    
    // Calculate frame delta and accumulator
    const delta = now - last;
    last = now;
    acc += delta;
    
    // Fixed time step updates
    while (acc >= dt) {
      update();
      acc -= dt;
    }
    
    // Render
    render();
    requestAnimationFrame(loop);
  }
})();
</script>
</body>
</html>
